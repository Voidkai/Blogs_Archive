# 垃圾回收机制算法介绍分析

## 引用计数法

1. 给每一个对象分配一个引用计数器
2. 每当有新的引用指向这个对象的时候，该引用计数器值+1
3. 而如果有引用结束了对该对象的引用，则计数器值-1.
4. 当垃圾回收线程检测到计数器值为0时回收期则会回收对象所使用的内存。

## 复制算法

1. 将内存分为大小相等的两个部分，每次只使用其中的一个部分，等这部分内存空间消耗完时，检查该空间里的所有对象。

2. 如果对象还被需要或者还有活性，则将这类对象复制到另一部分内存中，而不再需要的对象则不进行复制。

3. 当复制完成后，将之前被完全消耗的那部分空间全部清理。

   因此，在复制算法中，每一次内存清理的目标是一半的内存空间，相比引用计数法更简单高效。但是可使用的内存则降为了原来的一般。可以理解为以空间损失换来时间上的优化。

## 标记清除与标记压缩算法

标记清除算法就将垃圾回收分为了两部分：标记（mark）和清除（sweep）。

标记：根据特定的算法判断内存中的对象是否可以回收，其中常见的标记方法有前面提到的引用计数算法或是可达性分析算法等。

清除or压缩：清除与压缩的区别在与是否把可回收的那部分内存压缩到一起，进行整体垃圾清理。Java曾使用过标记压缩算法来实现垃圾回收。

## 分代收集算法

根据内存中的对象存活周期，将内存划分为几块，Java的虚拟机中一般把内存划分为老年代和新生代。

- 老年代：每次垃圾收集只有少量对象需要被回收。
- 新生代：每次垃圾回收时都有大量的对象需要被回收。
- 永久代：堆区之外，用来存储类、常量和方法等。

这样划分的目的是为了根据不同代的特点采用最合适的收集算法。

新生代都采取复制算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

而由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记压缩算法。